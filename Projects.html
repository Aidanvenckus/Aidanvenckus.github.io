
<html>
  <head>
    <meta charset = "utf-8">
    <title>Aidan Venckus</title>
    <link rel="icon" href="Images/icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Including the JavaScript-->
    <script src="script.js" defer> </script> <!--Defer: A script that will not run until after the page has loaded:-->
    <!-- Including the CSS Style Sheet-->
    <link rel="stylesheet" href="main.css">
  </head>

  <body class="Fade">
    <div class="header">
      <b class= "header_textBig TypeWriter typewriter_proj_title"> Projects </b>
      <br>
    </div>
    
    <!-- MOBILE NAV BAR TOGGLE-->
    <a href = "#" class ="toggle-button">
      <span class="bar"> </span>
      <span class="bar"> </span>
      <span class="bar"> </span>
    </a>
    <!-- NAVIGATION BAR -->
    <nav class = "navbar">    
      <div class="navbar-links menu-font">
        <ul>
          <li><a href="index.html">Home</a></li>
          <li><a href="resume.html">Resume</a></li>
          <li><a href="3DDesigns.html"> 3D Designs</a></li>
          <li><a href="#Top" class="currentpage" id="#Top"> Projects</a></li>
          <li><a href="https://aidanvenckus.netlify.app" >Apps</a></li>
          <li><a href="PCB.html"> PCB Design</a></li>
        </ul>
      </div>
    </nav>

    <!-- INTRODUCTION -->
    <p class="text">
      Here you will find Active and Past projects I've either made for school or in my freetime
      <br> <br>
      The code of the projects that I've done at UC Santa Cruz are mostly redacted in order to maintain academic integrity.
    </p>

    <!-- Topics Menu-->
    <center>
      <div>

        <a href="#UAV" class="link2">
        <div class="card enlarge card_padding">
        <!-- <figure style="width: 15%; float: left; text-align: center;"> -->
        <figure style="text-align: center;">
          <img class="image img_rounding" src="Images/UAV/UAV.png">
           <figcaption>UAV from Scratch</figcaption>
        </figure>
      </a> 
      </div>
    
      <a href="#Capstone" class="link2">
      <div class="card enlarge card_padding">
        <!-- <figure style="width: 15%; float: left; text-align: center;"> -->
        <figure style="text-align: center;">
          <img class="image img_rounding" src="Images/Bot/Bot_Vat.png"> </img>
          <figcaption>Capstone: Autonomous Bot </figcaption>
        </figure>
      </a>
      </div>

      <a href="#Osilliscope" class="link2">
      <div class="card enlarge card_padding">
        <figure style="text-align: center;">
          <img class="image img_rounding" src="Images/Tinyscope.png"> </img>
          <figcaption>"TinyScope" Homemade Osilliscope</figcaption>
        </figure>
      </a>
      </div>

     </div>
    </center>


    <!--PROJECT: From Scratch UAV-->
    <hr id="UAV">
    <p><strong class = "text" > Designing Flight - UAV from Scratch:</strong></p>
    <p class="text">
      In this project I designed and built a UAV as a start to my goal of creating a long distance autonomous drone that can be retrofitted for various tasks.
      I started this project by deciding on what type of drone I wanted to build, my favorite of which are fixed wing aircraft that have a glider type of airframe 
      because they are more fun to fly. I decided on doing a 4ft wingspan fixed wing single motor design that would have the motor mounted on top of it to allow for 
      gentler crashes and easier training. The firmware of the flight controller is ardupilot with mission planner installed to utilize the sensors and data avaliable.
    </p>

    <center> 
    <img class= "image img_padding" src="Images/UAV/UAV.png"> </img> <br>
    <i>*UAV running on Ardupilot Mission Planner</i> <br/> <br/>
    <img class= "image img_padding" src="Images/UAV/UAV_Crashed.png"> </img> <br>
    <i>*UAV has taken a few Hits</i> <br/> <br/>
    <img class= "image img_padding" src="Images/UAV/UAV_Disassembled.png"> </img> <br>
    <i>*Building the UAV</i> <br/> <br/>
    </center>
    <br>
    <center><b> UAV Specs: </b> </center>

    <dl class="text">
      <dt><u>Flight Controller - Matek F405 Wing Flight Controller</u></dt>
        <dd>- 2x Motors, 7x Servos outputs, 2x I2C</dd> 
        <dd>- 3x LEDs for FC STATUS</dd>
        <dd>- accelerometer + gyro + barometer + blackbox</dd>
        <dd>- 168MHz STM32F405</dd>
        <dd>- INAV operating system</dd>
        <center><img class= "image img_padding" src="Images/UAV/Flight_Controller.png"> </img></center> <br>
        <br/>
      <dt><u>Transmitter - TX16S</u></dt>
        <dd>- 16CH Radio Transmitter</dd>
        <dd>- Multi-Protocol OpenTX</dd>
        <center><img class= "image img_padding" src="Images/UAV/TX16S.png"> </img></center> <br>
        <br/>
      <dt><u>Reciever - RadioMaster R86C</u></dt>
        <dd>- Channels: 6 channels (PWM), 8 channels (SBUS)</dd>
        <dd>- Frequency range: 2400-2483.5Mhz</dd>
        <dd>- Signal format: Frsky D8 Compatible</dd>
        <center><img class= "image img_padding" src="Images/UAV/R86C.png"> </img></center> <br>
        <br/>
      <dt><u>GPS - Matek GPS Module SAM-M8Q Mini</u></dt>
        <dd>- Small (15cm x 25cm), Low power, light (7g) </dd>
        <center><img class= "image img_padding" src="Images/UAV/GPS.png"> </img></center> <br>
        <br/>
      <dt><u>Lipo Battery 11.1V 2200mAh 3S 25C </u></dt><br/>
      <dt><u>1400KV Brushless Motor + 30Amp ESC </u></dt><br/>
      <dt><u>SG90 Servos (9 grams)</u></dt><br/>
      <dt><u>8060 Propeller </u></dt><br/>
      </dl>

    <hr id="Capstone">
    <!--CAPSTONE: MECHATRONICS-->
    <p><strong class = "text" > Mechatronics Capstone Project:</strong></p>

    <center> 
      <b class = "text"> Autonomous Bot: </b> <br/>
      <img class= "image img_padding"
      src="Images/Bot/Bot_Vat.png"> </img> <br/>
      
      <b class = "text"> Randomized Challenge Field: </b> <br/>
      <img class= "image img_small"
      src="Images/Bot/RandomField.png"> </img> <br/>
    </center> 

    <p class="text">
      <b>Introduction:</b>
      The purpose of this project is to design, build, and program an autonomous robot 
      that can complete a randomly generated field. The completion of a given field 
      consists of detecting triangular vats scattered around that can be detected by infrared beacons on 
      top of them. In order to complete a vat, the bot needs to deposit a ping pong ball into the correct 
      hole. The proper hole is designated by a strip of black tape beneath the hole in addition to the 
      correct side which is designated by a trackwire on the perimeter of the correct face.
    </p>

    <p class="text">
      <b>Idea:</b>
      To build the bot I needed to utilize a combination of computer science, mechanical engineering, and eletrical engineering. 
      To start I first needed to design the bot based on the challenge and keep it as simple as possible. Our first goal was to 
      make a draft that would be ready for the peer design review (PDR). The approach taken was to construct a robot that could access two sides of the vat towers at a 
      time, using a V-shaped cavity in the center to attach to a corner, allowing a ping pong ball to be 
      deposited to any of the holes on either of these sides. Noting the vat tower faces are ten inches 
      wide, this strategy requires a large robot. Given the restriction of having a maximum dimension 
      in any direction of eleven inches, to account for the size, we set off to create a robot that could 
      fold in order to meet the specifications.
      </p>

      <center>
        <b class = "text"> Bot Draft: </b> <br/>
        <img class= "image img_small"
        src="Images/Bot/Bot_Draft1.png"> </img> <br/>
        <br/>
        <b class = "text"> Bot Draft with Size Restriction: </b> <br/>
        <img class= "image img_small"
        src="Images/Bot/Bot_Draft2.png"> </img> <br/>
        <br/>
      </center>

    <p class="text">
      <b>Approach:</b>
      The strategy consists of attaching to one corner of the tower and using two track wire sensors
      to quickly identify if the correct face of the tower is accessible from the currently attached
      corner. If the correct face is found, the upper deposit arms, consisting of servos and tape sensors
      to control gates on the arms depending on the location of the black tape on the vat tower and the
      correct face location, act as a gravity feeder. In the case the robot attaches to a corner where the
      correct face is inaccessible, an algorithm is implemented to attempt to attach the bot to a new
      corner of the vat tower. We aim to use bumpers on the deposit arms for obstacle detection and to
      help aid the corner mating procedure. With this approach, the robot is capable of completing any
      tower after attempting a maximum of two different corner locations. This approach was chosen
      due to the design easing the need for a precision ball release method as well as the speed
      improvement gained by the simpler method of identifying proper alignment with the tower.
    </p>
    
    <center>
    <b class = "text"> Bot Solidworks: </b> <br/>
      <img class= "image img_padding"
      src="Images/Bot/Bot_Solidworks1.png"> </img> <br/>
      <br/>
      <b class = "text"> Bot Solidworks with Vat: </b> <br/>
      <img class= "image img_small"
      src="Images/Bot/Bot_Solidworks2.png"> </img> <br/>
      <br/>
      <b class = "text"> Bot Folding: </b> <br/>
      <img class= "image img_small"
      src="Gifs/Bot_Bend.gif"> </img> <br/>
      <br/>
      <b class = "text"> Bot Full Drawing: </b> <br/>
      <img class= "image img_small"
      src="Images/Bot/Bot_Full_Drawing.png"> </img> <br/>
      <br/>
      <b class = "text"> Bot Top Drawing: </b> <br/>
      <img class= "image img_small"
      src="Images/Bot/Bot_Top_Drawing.png"> </img> <br/>
      <br/>
      <b class = "text"> Bot Bottom Drawing: </b> <br/>
      <img class= "image img_small"
      src="Images/Bot/Bot_Bottom_Drawing.png"> </img> <br/>
      <br/>
    </center>
    
    <p class="text">
      <b>Mechanical design:</b>
      A unique aspect of this course is using SolidWorks to create designs that are then cut 
      using a laser cutter for quick and accurate manufacturing and prototyping. The process starts out 
      with an idea, which we then CAD each individual object called a part using SolidWorks. As soon 
      as a working model is made, each part is then taken into an assembly where it is then “mated” 
      together to see if it will all fit together and no collisions exist. By creating this solid model, we 
      can confirm and identify shortcomings before attempting any physical prototyping. To get the 
      parts prepared for laser cutting, each part is taken into an assembly where it is mated onto a 
      bottom face so all the parts are lying horizontally. It then gets converted from an assembly to a 
      drawing where the horizontally laid parts become drawings on a sheet. It then needs to be scaled 
      to a 1:1 ratio where it can then be exported as a DXF (autoCAD Drawing interchange) file to be 
      cut on the laser cutter.
    </p>
    
    <center>
    <b class = "text"> Bot Microcontroller Pin Layout: </b> <br/>
      <img class= "image img_padding"
      src="Images/Bot/UNO_Pins.png"> </img> <br/>
      <br/>
      <b class = "text"> Bot Microcontroller: </b> <br/>
      <img class= "image img_small"
      src="Images/Bot/UNO.png"> </img> <br/>
      <br/>
      <b class = "text"> Bot Bottom with Wiring: </b> <br/>
      <img class= "image img_small"
      src="Images/Bot/Bot_Wiring.png"> </img> <br/>
      <br/>
    </center>

    <p class="text">
      <b>Electrical design:</b>
      The main portions of the electrical work for the bot came from doing the beacon detector and trackwire detector 
      which was done through the use of PCBs. The beacon detector is responsible for finding the ring of IR LEDs that lay on top of the vat
      tower. The goal of the beacon detector is to accept and identify a 2 [KHz] signal while rejecting
      1.5 and 2.5 [KHz] signals. For the circuit we had the input go into 4 gain stages of non-inverting op amps, then through a 
      bandpass filter that attenuates the signal, through a peak detector, and lastly to a comparator to make it a digital output
      <a class="link" href="PCB.html">(PCB info)</a>.
    </p>
      
    <p class="text">
      The trackwire circuit is responsible for detecting the trackwire through the vat tower which is
      a 12V wire with oscillating 25kHz current running through it causing an oscillating magnetic
      field. The circuit utilizes a tank circuit which acts as a resonant oscillator
      and gets the signal from the trackwire's magnetic field through it’s inductor. The capacitor fills up with charge
      and it oscillates because the capacitor gives charge to the inductor and then the capacitor flips
      polarity (this causes a sine wave). It is described as a tank because the oscillation can be
      imagined as a tank with water in it swishing back and forth. From there it consists of three gain
      stages of non-inverting op amps. It then goes to a peak detector to provide rectification of the inputted AC signal. The
      output is then buffered with an LED at the end (the voltage difference turns the LED off when a
      trackwire is detected) <a class="link" href="PCB.html">(PCB info)</a>.
    </p>

    <p class="text">
      Other electronic components include working with various motors and acutators such as servos (fixed and continour), 
      DC motors (geared and worm geared), H-bridges. In addtion to this we had various sensors such as tape sensors reading both 
      digital and analog signals, tripwire (laser) triggers, switches acting as bump sensors, and many 5V and 3V regulators to drop 
      us down from the 9.9V battery power supply.
    </p>

    <center>
    <b class = "text"> Bot State Machine: </b> <br/>
    <img class= "image img_padding"
      src="Images/Bot/StateMachine.png"> </img> <br/>
    <br/>
    </center>

    <p class="text">
      <b>Software design:</b>
      The code for the bot utilizes a hierarchical state machine design which acts as a standard
      Finite state machine but each state can have their own “sub” state machines within them. The
      way that this works is an event is passed to the lowest level it can go and if the state is handled
      the sub state machine “consumes” the event and returns ES_NO_EVENT to the top level state
      machine.
    </p>
    
    <p class="text">
      The <b>top level states</b> used consisted of a ResetState, a FindingVatState, a AtVatState, a
      FiringState, and a RunAwayState.
    </p>
      
    <p class="text">
      The <b>ResetState</b> deals with the initialization of the bot. This
      includes raising or lowering the vtrack and resetting the ball drum to allow it to be filled with
      new ping pong balls.
    </p>
    
    <p class="text">
      The <b>FindingVatState</b> deals with finding the vats and driving towards them while dealing with
      tape events. It transitions into AtVatState when a bumper is hit. This state handles the case when
      spinning and no beacons are found after an extended period of time.
    </p>
    
    <p class="text">
      The <b>AtVatState</b> deals with maneuvering around the vat tower and attempts to cause a laser
      event. This state ignores tape events when realigning with the vat tower after failing with a pivot
      only. This can be optimized to react to tape events to stay within the boundaries, however, given
      that the fields are generated in a way that the correct face must be reachable, we found it was
      mostly unnecessary for completing the task. This state also handles the maneuvering when mated
      with the wrong face of the tower and the case when the bot is incapable of maneuvering to the
      next face.
    </p>

    <p class="text">
      The <b>FiringState</b> deals with attempting the full mate with the tower after the laser is tripped.
      Once fully mated, the state deals with readjusting to ensure the bot is flat and checks if at the
      correct face. This was necessary as using the method of going full speed to slide into the corner
      often resulted with the bot being positioned propped up against the corner. As our firing method
      relies on a gravity deposit, this had to be corrected by backing up and coming in at a slower
      speed. This state also handles checking for the trackwire, and, if at the correct face, the state
      handles depositing the ball into the correct hole by moving the appropriate servos. The servos
      that are moved are the ball drum servo, the middle servo determining the side the ball would roll
      down, and the arm servos if tape was found on inner two holes of the tower.
    </p>
    <p class="text">
      The <b>RunAwayState</b> deals with getting the bot in a position in which it could likely find a new
      vat tower. This state is entered either following depositing a ping pong ball or in the case that
      both attempts to reach a new corner of the vat fails. It is used to get out of situations in which the
      bot can not make progress. The sequence is simple, starting with backing up from the tower and
      then turning partially while ignoring beacons. It then transitions into the FindingVatState and
      continues its spin now looking for beacons. This state could be converted into a tape follow state
      that would search for corners of the field to give better chances at finding all the towers. This
      was implemented though we decided that the basic method of spinning was quick and was
      efficient at getting the two towers needed.
    </p>

    <p class="text">
      Our design implemented three <b>substate machines</b>. FindingVat, AtVat, and Firing are
      implemented as substate machines.
    </p>

    <hr>
    <!--Mech Lab 3-->
    <p><strong class = "text" > Mechatronics Lab3:</strong></p>

    <center> 
      <b class = "text"> Motor testing board: </b> <br/>
      <div class="container img_padding">
          <img class="image" src="Images/MotorLab.png">
      </div>
    </center>

    <p class="text">
      In this lab I got the chance to test various motors to be used in the capstone project. I got the chance to use 
      servos, stepper motors, and DC motors. We had a power distribution board that was able to power the motors with 
      5V and 12V when necessary and was able to use H-bridges and various dedicated boards to run the motors. In addition 
      we had to solve some inductive kickback when working with the DC motors and worked on different type of step methods 
      for the stepper motor. I had the chance to try wave step, full step, and half step. The type of step that is most often 
      used is micro step with sin wave phasing but I didn't have a chace to try it.
    </p>

    <hr>
    <!--Mech Lab 2-->
    <p><strong class = "text" > Mechatronics Lab2:</strong></p>

    <center> 
      <b class = "text"> Lasercutting Bot Chassis: </b> <br/>
      <div class="container img_padding">
          <img class="image" src="Gifs/LaserCut.gif">
      </div>
    </center>

    <center> 
    <b class = "text"> Practice Bot Fully Assembled: </b> <br/>
      <img class= "image img_small"
      src="Images/Bot_Iso.png"> </img> <br/>
      <img class= "image img_small"
      src="Images/Bot_Front.png"> </img> <br/>
      <img class= "image img_small"
      src="Images/Bot_Solidworks.jpg"> </img> <br/>
    </center>

    <p class="text">
      This is the Bot I created by using solidworks to design the individual parts, assembled them together and made 
      sure all the parts fit together. I then put all the parts on one plane and created a cutout design to then send 
      to the laser cutter. 
    </p>

    (More detail will be added later...)
    
    <hr>
    <!--Mech Lab 1-->
    <p><strong class = "text" > Mechatronics Lab1:</strong></p>
    
    <center> 
    <b class = "text"> Beacon Demonstration: </b> <br/>
    <div class="container img_padding">
      <center> <img class="image" src="Gifs/Beacon.gif"> </center>  
    </div>

    
    <b class = "text"> Beacon Circuit: </b> <br/>
      <img class= "image img_padding"
      src="Images/PCBs/BeaconCircuit.jpeg"> </img> <br/>
    </center>

    <p class="text">
      This was the final product of creating the Beacon circuit that could detect an IR LED from over 20 feet away.
    </p>
    <center class="text"> <b> Beacon Detector Stages: </b> </center>
    <dl class="text">
      <dt><u>Input Stage</u></dt>
      <dd>- Starts with a Photoresistive Transistor which gives a voltage based on IR light levels and flows through a Transresistive op-amp</dd><br/>
      <dt><u>Amplification Stage</u></dt>
      <dd>- Takes the Input and Amplifies the signal with 6 (11x gain) non-inverting op-amps</dd><br/>
      <dt><u>Filtering Stage</u></dt>
      <dd>- With this amplified signal we filter out anything but the 2khz filter with a 2 stage 4th order butterworth bandpass</dd><br/>
      <dt><u>Peak Detection Stage</u></dt>
      <dd>- The newly filtered signal goes to a peak detector to make sure we have high wave outputs</dd><br/>
      <dt><u>Comparator and hysterisis Stage</u></dt>
      <dd>- The comparator takes the signal and turns it into a digital signal (1 High or 0 Low) by the use of voltage thresholds and hysterisis</dd><br/>
      <dt><u>Output Stage</u></dt>
      <dd>- The digital signal now gets passed to a buffer and LED (Green) to be able to show the resulting output</dd><br/>
    </dl>

    (More detail will be added later...)

    <hr>
    <!--Mech Lab 0-->
    <p><strong class = "text" > Mechatronics Lab0:</strong></p>

    <center> 
      <video class = "Vid" controls>
      <source src="Videos/Part7_Sideways.mp4" type="video/mp4">
    </video> 
    <br />
    </center>

    <p class="text">
      This was part 7 of the Mechatronics Lab0, used the stick to the right wall maze rule to get to the end...
      Too sleepy to put more description right now.
    </p>

    <center>
    <br />
    <video class = "Vid" controls>
      <source src="Videos/Part8_Sideways.mp4" type="video/mp4">
    </video> 
  </center>

  <p class="text">
    This was part 8 of the Mechatronics Lab0, we needed to implement a hierarchical state machine instead of a finite state machine...
    It also has a little dance which I accidently coded to be 2x as long as it was supposed to be.
    Too sleepy to put more description right now.
  </p>

    <!--PROJECT: OSILLISCOPE-->
    <hr id="Osilliscope">
    <p><strong class = "text" > "TinyScope" Osilliscope:</strong></p>

    <center> <img class= "image img_padding" src="Images/Tinyscope.png" ></img> </center>
    

    <p class="text">
      The "Tinyscope" dual-channel oscilloscope that I designed for my Embedded System Design class at UCSC. 
      The Tinyscope is made from a PSoC-6 microcontroller programmed and compiled in the PSoC Creator (ver 4.4) that holds similar features as a standard osilliscope would. 
      <br><br>
      An oscilloscope is a type of electronic test equipment that allows the user to probe analog signals and plot them as digital signals in units of voltages over time. 
      Oscilloscopes are useful as they assist in finding the amplitude, frequency, distortion, and other characteristics of signals. 
      The Tinyscope allows all this information to be found for a limited range of voltages at a fraction of the size and cost of a standard oscilloscope.
    </p>

    <!-- Tinyscope Features -->
    <center> <b class="text"> List of Features: </b> </center>
 
    <!-- dl is a description list 
          dt: is description term 
          dd: description definition -->
    <dl class="text">
    <dt><u>2 Waveform Channels</u></dt>
    <dt>Sampling rate of 250k samples/second for all 4 ADC channels.</dt>
      <dd>- 2 Channels for Analog Signals</dd>
      <dd>- 2 Channels for Potentiometers’ Readings</dd>
      <br>
    <dt><u>2 Waveform Modes</u></dt>
      <dd>- Free-Running</dd>
      <dd>- Triggered</dd>
      <br>
    <dt><u>User Input to alter Waveform</u></dt>
      <dd>- Xscaling</dd>
      <dd>- Yscaling</dd>
      <dd>- Trigger Level</dd>
      <dd>- Trigger Slope</dd>
      <dd>- Waveform Stopped / Started</dd>
      <br>
    <dt><u>Frequency Calculation</u></dt>
    <dt><u>Scrolling Waveforms (via Potentiometers)</u></dt>
    </dl>
  
    
    <center>
      <b class = "text"> TinyScope Schematic: </b> <br>
      <img class= "image img_padding" src="Images/Tinyscope_Schematic.png"> </img> <br>

      <b class = "text"> TinyScope FlowChart: </b> <br>
      <img class= "image img_padding" src="Images/TinyscopeFlow.png"> </img> <br>

      <b class = "text"> TinyScope Overview: </b> <br>
      <img class= "image img_padding" src="Images/Tinyscope_Overview.png"> </img> <br>
    </center>

    <!--PROJECT: ELECTRIC BIKE-->
    <!-- <hr>
    <p><strong class = "text" > DIY - Electric Bike:</strong></p>
    <p class="text">
      In progress...
    </p> -->

    <!--PROJECT: PYTHON-->
    <!-- <hr>
    <p><strong class = "text" > Python Projects:</strong></p>
    <p class="text">
      Python Dungeon Crawler In Progress...
    </p> -->
    
    <!-- Python 
    <iframe height="600px" width="100%" src="https://replit.com/@AidanVenckus/PyDungeonCrawl?lite=true&amp;outputonly=1" scrolling="yes" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
    </iframe>
    -->

     <!--PROJECT: C
     <hr>
     <p><strong class = "text" >C Projects:</strong></p>
     <p class="text">
       In progress...
     </p>
     
     <iframe height="600px" width="100%" src="https://replit.com/@AidanVenckus/Testing-C?lite=true&amp;outputonly=1" scrolling="yes" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals">
     </iframe>
     -->

    <br>
    <br> <!--SPACE-->
    <br>

    <div class="footer">  
      <br>
    </div>

  </body>
</html>